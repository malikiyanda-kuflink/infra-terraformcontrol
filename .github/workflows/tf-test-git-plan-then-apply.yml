name: tf-test-git-layered

on:
  push:
    branches: [ test-git ]
    paths:
      - environments/test-git/**
      - modules/**
  workflow_dispatch:
    inputs:
      auto_apply:
        description: "Auto-apply when a layer has changes?"
        type: boolean
        default: true
        required: false

concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: eu-west-2
  TF_IN_AUTOMATION: "true"
  TF_STATE_BUCKET: kuflink-test-states
  TF_LOCK_TABLE: kuflink-tf-locks-test
  ROLE_ARN: arn:aws:iam::137167813802:role/kuflink-test-github-oidc-terraform
  TERRAFORM_PATH: "C:\\terraform\\terraform.exe"

jobs:
  # ===== FOUNDATION =====
  foundation:
    name: foundation
    runs-on: [self-hosted, tf-runner]
    permissions: { id-token: write, contents: read }
    env:
      LAYER: foundation
      TF_WORKDIR: environments/test-git/foundation
      TF_STATE_KEY: test-git/foundation/terraform.tfstate
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify Terraform
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          Write-Host "TERRAFORM_PATH: $env:TERRAFORM_PATH  Exists: $(Test-Path $env:TERRAFORM_PATH)"
          & "$env:TERRAFORM_PATH" version

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" init `
            -backend-config="bucket=$env:TF_STATE_BUCKET" `
            -backend-config="key=$env:TF_STATE_KEY" `
            -backend-config="region=$env:AWS_REGION" `
            -backend-config="dynamodb_table=$env:TF_LOCK_TABLE" `
            -backend-config="encrypt=true"

      - name: Terraform Plan (detect changes)
        id: plan
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

          # Run plan with no-color flag and capture outputs
          $planArgs = @('plan', '-no-color', '-input=false', '-out=tfplan.bin', '-detailed-exitcode')
          
          try {
            & "$env:TERRAFORM_PATH" @planArgs 2>&1 | Tee-Object -FilePath "plan.output.txt"
            $code = $LASTEXITCODE
          } catch {
            $code = 1
            $_.Exception.Message | Out-File -FilePath "plan.output.txt" -Append
          }

          if ($code -eq 2) {
            'has_changes=true'  | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } elseif ($code -eq 0) {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=false'     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Terraform plan failed with exit code $code" -ForegroundColor Red
          }

          # Only produce views if plan file exists
          if (Test-Path "tfplan.bin") {
            & "$env:TERRAFORM_PATH" show -no-color tfplan.bin > tfplan.txt
            & "$env:TERRAFORM_PATH" show -json     tfplan.bin > tfplan.json
          }

          # Ensure the PowerShell step always exits successfully
          $global:LASTEXITCODE = 0
          exit 0
          id: plan
          working-directory: ${{ env.TF_WORKDIR }}
          shell: powershell
          run: |
            Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
            $planArgs = @('plan','-input=false','-out=tfplan.bin','-detailed-exitcode')
            & "$env:TERRAFORM_PATH" @planArgs
            $code = $LASTEXITCODE
            if ($code -eq 2) { 'has_changes=true'  | Out-File -FilePath $env:GITHUB_OUTPUT -Append }
            elseif ($code -eq 0) { 'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append }
            else { throw "terraform plan failed with exit code $code" }

            # Always produce human/json views for the summary/artifact
            & "$env:TERRAFORM_PATH" show -no-color tfplan.bin > tfplan.txt
            & "$env:TERRAFORM_PATH" show -json     tfplan.bin > tfplan.json

      - name: Summarize plan (outputs)
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          $summary = @()
          $summary += "### Plan - $($env:LAYER)"
          $summary += ""
          $summary += "- Changes: ${{ steps.plan.outputs.has_changes }}"

          if (Test-Path "tfplan.json") {
            $tf = (Get-Content tfplan.json -Raw) | ConvertFrom-Json
            
            if ($tf.resource_changes) {
              $rc = $tf.resource_changes
              $adds     = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'create' }).Count
              $updates  = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'update' }).Count
              $deletes  = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'delete' }).Count
              $repl     = ($rc | Where-Object { ($_.change.actions -contains 'create') -and ($_.change.actions -contains 'delete') }).Count
              $summary += "- Adds: $adds, Changes: $updates, Destroys: $deletes, Replacements: $repl"
            }

            # Parse outputs but filter sensitive ones
            if ($tf.output_changes) {
              # Use more robust grouping based on common terraform patterns
              $outputGroups = @{
                "VPC and Networking" = @()
                "IAM Roles and Policies" = @()
                "Database and Storage" = @()
                "Compute and EC2" = @()
                "Security and Keys" = @()
                "Application Config" = @()
                "Other Resources" = @()
              }
              
              $sensitiveCount = 0
              
              foreach ($outputName in $tf.output_changes.PSObject.Properties.Name) {
                $outputChange = $tf.output_changes.$outputName
                
                # CRITICAL: Skip sensitive outputs for security
                if ($outputChange.after_sensitive -eq $true) {
                  $sensitiveCount++
                  continue
                }
                
                if ($outputChange.after -ne $null) {
                  # Format the value
                  if ($outputChange.after -is [string]) {
                    $displayValue = $outputChange.after
                  } elseif ($outputChange.after -is [array]) {
                    $displayValue = "[$($outputChange.after -join ', ')]"
                  } else {
                    $displayValue = $($outputChange.after | ConvertTo-Json -Compress)
                  }
                  
                  $outputLine = "- $outputName = $displayValue"
                  
                  # More comprehensive grouping logic
                  switch -Regex ($outputName.ToLower()) {
                    "(vpc|subnet|gateway|route|cidr|network|internet)" { 
                      $outputGroups["VPC and Networking"] += $outputLine; break 
                    }
                    "(role_arn|instance_profile|iam_|policy)" { 
                      $outputGroups["IAM Roles and Policies"] += $outputLine; break 
                    }
                    "(db_|database|rds_|redshift|dms_)" { 
                      $outputGroups["Database and Storage"] += $outputLine; break 
                    }
                    "(ami|instance|ec2_|compute)" { 
                      $outputGroups["Compute and EC2"] += $outputLine; break 
                    }
                    "(key|ssh_|ssl_|cert|security)" { 
                      $outputGroups["Security and Keys"] += $outputLine; break 
                    }
                    "(app_|api_|url|env|config)" { 
                      $outputGroups["Application Config"] += $outputLine; break 
                    }
                    default { 
                      $outputGroups["Other Resources"] += $outputLine 
                    }
                  }
                }
              }
              
              $totalOutputs = ($tf.output_changes.PSObject.Properties | Measure-Object).Count
              $visibleOutputs = $totalOutputs - $sensitiveCount
              $summary += ""
              $summary += "**Planned Outputs ($visibleOutputs shown, $sensitiveCount sensitive hidden):**"
              
              # Display groups that have outputs
              foreach ($groupName in $outputGroups.Keys | Sort-Object) {
                $groupOutputs = $outputGroups[$groupName]
                if ($groupOutputs.Count -gt 0) {
                  $summary += ""
                  $summary += "**$groupName ($($groupOutputs.Count)):**"
                  $summary += $groupOutputs
                }
              }
              
            } else {
              $summary += ""
              $summary += "**No output changes found in JSON**"
            }

          } else {
            $summary += "- **ERROR: tfplan.json not found**"
          }

          # Collapsed full plan
          if (Test-Path "tfplan.txt") {
            $summary += ""
            $summary += "<details><summary>Full text plan (click to expand)</summary>"
            $summary += ""
            $summary += '```'
            $t = Get-Content tfplan.txt -Raw
            if ($t.Length -gt 15000) { 
              $t = $t.Substring(0,15000) + "`n... (truncated - download artifact for full plan) ..." 
            }
            $summary += $t
            $summary += '```'
            $summary += "</details>"
          }

          $summary -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          working-directory: ${{ env.TF_WORKDIR }}
          shell: powershell
          run: |
            $summary = @()
            $summary += "### Plan - $($env:LAYER)"
            $summary += ""
            $summary += "- Changes: ${{ steps.plan.outputs.has_changes }}"

            if (Test-Path "tfplan.json") {
              $tf = (Get-Content tfplan.json -Raw) | ConvertFrom-Json
              
              if ($tf.resource_changes) {
                $rc = $tf.resource_changes
                $adds     = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'create' }).Count
                $updates  = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'update' }).Count
                $deletes  = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'delete' }).Count
                $repl     = ($rc | Where-Object { ($_.change.actions -contains 'create') -and ($_.change.actions -contains 'delete') }).Count
                $summary += "- Adds: $adds, Changes: $updates, Destroys: $deletes, Replacements: $repl"
              }

              # Parse outputs but filter sensitive ones
              if ($tf.output_changes) {
                # Collect non-sensitive outputs and group them
                $iamOutputs = @()
                $vpcOutputs = @()
                $otherOutputs = @()
                $sensitiveCount = 0
                
                foreach ($outputName in $tf.output_changes.PSObject.Properties.Name) {
                  $outputChange = $tf.output_changes.$outputName
                  
                  # CRITICAL: Skip sensitive outputs for security
                  if ($outputChange.after_sensitive -eq $true) {
                    $sensitiveCount++
                    continue
                  }
                  
                  if ($outputChange.after -ne $null) {
                    # Format the value
                    if ($outputChange.after -is [string]) {
                      $displayValue = $outputChange.after
                    } elseif ($outputChange.after -is [array]) {
                      $displayValue = "[$($outputChange.after -join ', ')]"
                    } else {
                      $displayValue = $($outputChange.after | ConvertTo-Json -Compress)
                    }
                    
                    $outputLine = "- $outputName = $displayValue"
                    
                    # Group outputs by type based on name patterns
                    if ($outputName -match "role_arn|instance_profile|iam_") {
                      $iamOutputs += $outputLine
                    } elseif ($outputName -match "vpc_|subnet|gateway|route|cidr") {
                      $vpcOutputs += $outputLine
                    } else {
                      $otherOutputs += $outputLine
                    }
                  }
                }
                
                $totalOutputs = ($tf.output_changes.PSObject.Properties | Measure-Object).Count
                $summary += ""
                $summary += "**Planned Outputs ($($totalOutputs - $sensitiveCount) shown, $sensitiveCount sensitive hidden):**"
                
                # Display grouped outputs
                if ($vpcOutputs.Count -gt 0) {
                  $summary += ""
                  $summary += "**üåê VPC & Networking:**"
                  $summary += $vpcOutputs
                }
                
                if ($iamOutputs.Count -gt 0) {
                  $summary += ""
                  $summary += "**üîê IAM Roles & Policies:**"
                  $summary += $iamOutputs
                }
                
                if ($otherOutputs.Count -gt 0) {
                  $summary += ""
                  $summary += "**üìã Other Resources:**"
                  $summary += $otherOutputs
                }
                
              } else {
                $summary += ""
                $summary += "**No output changes found in JSON**"
              }

            } else {
              $summary += "- **ERROR: tfplan.json not found**"
            }

            # Collapsed full plan
            if (Test-Path "tfplan.txt") {
              $summary += ""
              $summary += "<details><summary>Full text plan (click to expand)</summary>"
              $summary += ""
              $summary += '```'
              $t = Get-Content tfplan.txt -Raw
              if ($t.Length -gt 15000) { 
                $t = $t.Substring(0,15000) + "`n... (truncated - download artifact for full plan) ..." 
              }
              $summary += $t
              $summary += '```'
              $summary += "</details>"
            }

            $summary -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            working-directory: ${{ env.TF_WORKDIR }}
            shell: powershell
            run: |
              $summary = @()
              $summary += "### Plan - $($env:LAYER)"
              $summary += ""
              $summary += "- Changes: ${{ steps.plan.outputs.has_changes }}"

              if (Test-Path "tfplan.json") {
                $tf = (Get-Content tfplan.json -Raw) | ConvertFrom-Json
                
                if ($tf.resource_changes) {
                  $rc = $tf.resource_changes
                  $adds     = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'create' }).Count
                  $updates  = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'update' }).Count
                  $deletes  = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'delete' }).Count
                  $repl     = ($rc | Where-Object { ($_.change.actions -contains 'create') -and ($_.change.actions -contains 'delete') }).Count
                  $summary += "- Adds: $adds, Changes: $updates, Destroys: $deletes, Replacements: $repl"
                }

                # Try to parse outputs from output_changes (most common location)
                $outputsFound = $false
                if ($tf.output_changes) {
                  $outputCount = ($tf.output_changes.PSObject.Properties | Measure-Object).Count
                  $summary += ""
                  $summary += "**Planned Outputs ($outputCount found):**"
                  
                  foreach ($outputName in $tf.output_changes.PSObject.Properties.Name) {
                    $outputChange = $tf.output_changes.$outputName
                    if ($outputChange.after -ne $null) {
                      # Handle different types of output values
                      if ($outputChange.after -is [string]) {
                        $summary += "- $outputName = $($outputChange.after)"
                      } elseif ($outputChange.after -is [array]) {
                        $summary += "- $outputName = [$($outputChange.after -join ', ')]"
                      } else {
                        $summary += "- $outputName = $($outputChange.after | ConvertTo-Json -Compress)"
                      }
                      $outputsFound = $true
                    }
                  }
                }
                
                # Fallback: try planned_values.outputs if output_changes didn't work
                if (-not $outputsFound -and $tf.planned_values -and $tf.planned_values.outputs) {
                  $outputCount = ($tf.planned_values.outputs.PSObject.Properties | Measure-Object).Count
                  $summary += ""
                  $summary += "**Planned Outputs from planned_values ($outputCount found):**"
                  
                  foreach ($outputName in $tf.planned_values.outputs.PSObject.Properties.Name) {
                    $outputValue = $tf.planned_values.outputs.$outputName
                    if ($outputValue.value -ne $null) {
                      if ($outputValue.value -is [string]) {
                        $summary += "- $outputName = $($outputValue.value)"
                      } elseif ($outputValue.value -is [array]) {
                        $summary += "- $outputName = [$($outputValue.value -join ', ')]"
                      } else {
                        $summary += "- $outputName = $($outputValue.value | ConvertTo-Json -Compress)"
                      }
                      $outputsFound = $true
                    }
                  }
                }
                
                if (-not $outputsFound) {
                  $summary += ""
                  $summary += "**No output values found in JSON**"
                }

              } else {
                $summary += "- **ERROR: tfplan.json not found**"
              }

              # Collapsed full plan
              if (Test-Path "tfplan.txt") {
                $summary += ""
                $summary += "<details><summary>Full text plan (click to expand)</summary>"
                $summary += ""
                $summary += '```'
                $t = Get-Content tfplan.txt -Raw
                if ($t.Length -gt 15000) { 
                  $t = $t.Substring(0,15000) + "`n... (truncated - download artifact for full plan) ..." 
                }
                $summary += $t
                $summary += '```'
                $summary += "</details>"
              }

              $summary -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8

      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.LAYER }}-${{ github.sha }}
          path: |
            ${{ env.TF_WORKDIR }}/tfplan.bin
            ${{ env.TF_WORKDIR }}/tfplan.txt
            ${{ env.TF_WORKDIR }}/tfplan.json
          retention-days: 7

      - name: Terraform Apply (only if changes)
        if: steps.plan.outputs.has_changes == 'true' && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true'
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" apply -input=false -auto-approve tfplan.bin
          
# ===== PLATFORM (depends on foundation) =====
  platform:
    name: platform
    needs: [ foundation ]
    runs-on: [self-hosted, tf-runner]
    permissions: { id-token: write, contents: read }
    env:
      LAYER: platform
      TF_WORKDIR: environments/test-git/platform
      TF_STATE_KEY: test-git/platform/terraform.tfstate

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" init `
            -backend-config="bucket=$env:TF_STATE_BUCKET" `
            -backend-config="key=$env:TF_STATE_KEY" `
            -backend-config="region=$env:AWS_REGION" `
            -backend-config="dynamodb_table=$env:TF_LOCK_TABLE" `
            -backend-config="encrypt=true"

      - name: Terraform Plan (detect changes)
        id: plan
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

          # Run plan and capture outputs (ensure step doesn't fail)
          $planArgs = @('plan','-input=false','-out=tfplan.bin','-detailed-exitcode')
          
          try {
            & "$env:TERRAFORM_PATH" @planArgs 2>&1 | Tee-Object -FilePath "plan.output.txt"
            $code = $LASTEXITCODE
          } catch {
            $code = 1
            $_.Exception.Message | Out-File -FilePath "plan.output.txt" -Append
          }

          if ($code -eq 2) {
            'has_changes=true'  | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } elseif ($code -eq 0) {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=false'     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Terraform plan failed with exit code $code" -ForegroundColor Red
          }

          # Only produce views if plan file exists
          if (Test-Path "tfplan.bin") {
            & "$env:TERRAFORM_PATH" show -no-color tfplan.bin > tfplan.txt
            & "$env:TERRAFORM_PATH" show -json     tfplan.bin > tfplan.json
          }

          # Ensure the PowerShell step always exits successfully
          $global:LASTEXITCODE = 0
          exit 0

      - name: Summarize plan (outputs + errors if any)
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          # Function to strip ANSI color codes
          function Strip-AnsiCodes {
            param([string]$InputString)
            return $InputString -replace '\x1b\[[0-9;]*m', ''
          }

          $summary = @("### Plan - $($env:LAYER)",
                      "",
                      "- Plan OK: ${{ steps.plan.outputs.plan_ok }}",
                      "- Changes: ${{ steps.plan.outputs.has_changes }}")
          
          if (Test-Path "tfplan.json") {
            $tf = (Get-Content tfplan.json -Raw) | ConvertFrom-Json
            if ($tf.resource_changes) {
              $rc = $tf.resource_changes
              $adds = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'create' }).Count
              $updates = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'update' }).Count
              $deletes = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'delete' }).Count
              $repl = ($rc | Where-Object { ($_.change.actions -contains 'create') -and ($_.change.actions -contains 'delete') }).Count
              $summary += "- Adds: $adds, Changes: $updates, Destroys: $deletes, Replacements: $repl"
            }
            if ($tf.outputs) {
              $summary += ""
              $summary += "**Planned Outputs:**"
              foreach ($k in $tf.outputs.PSObject.Properties.Name) {
                $val = $tf.outputs.$k.value
                $summary += "- $k = $val"
              }
            }
          }
          
          # ALWAYS show terraform output for debugging - strip ANSI codes
          if (Test-Path "plan.output.txt") {
            $rawOutput = Get-Content plan.output.txt -Raw
            $cleanOutput = Strip-AnsiCodes -InputString $rawOutput
            if ($cleanOutput.Trim().Length -gt 0) {
              $summary += ""
              $summary += "**Terraform Output (Debug):**"
              $summary += ""
              $summary += '```'
              $summary += $cleanOutput
              $summary += '```'
            }
          }
          
          if (Test-Path "tfplan.txt") {
            $t = Get-Content tfplan.txt -Raw
            if ($t.Length -gt 50000) { $t = $t.Substring(0,50000) + "`n... (truncated) ..." }
            $summary += ""
            $summary += "<details><summary>Full text plan</summary>"
            $summary += ""
            $summary += '```'
            $summary += $t
            $summary += '```'
            $summary += "</details>"
          }
          
          $summary -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.LAYER }}-${{ github.sha }}
          path: |
            ${{ env.TF_WORKDIR }}/tfplan.bin
            ${{ env.TF_WORKDIR }}/tfplan.txt
            ${{ env.TF_WORKDIR }}/tfplan.json
            ${{ env.TF_WORKDIR }}/plan.output.txt
          retention-days: 7

      - name: Terraform Apply (only if plan OK & changes)
        if: steps.plan.outputs.plan_ok == 'true' && steps.plan.outputs.has_changes == 'true' && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true'
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" apply -input=false -auto-approve tfplan.bin


# ===== DATA =====
  data:
    name: data
    needs: [ platform ]
    runs-on: [self-hosted, tf-runner]
    permissions: { id-token: write, contents: read }
    env:
      LAYER: data
      TF_WORKDIR: environments/test-git/data
      TF_STATE_KEY: test-git/data/terraform.tfstate
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Terraform Init
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" init `
            -backend-config="bucket=$env:TF_STATE_BUCKET" `
            -backend-config="key=$env:TF_STATE_KEY" `
            -backend-config="region=$env:AWS_REGION" `
            -backend-config="dynamodb_table=$env:TF_LOCK_TABLE" `
            -backend-config="encrypt=true"
            
      - name: Terraform Plan (detect changes)
        id: plan
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          
          # Run plan and capture outputs (ensure step doesn't fail)
          $planArgs = @('plan','-input=false','-out=tfplan.bin','-detailed-exitcode')
          
          try {
            & "$env:TERRAFORM_PATH" @planArgs 2>&1 | Tee-Object -FilePath "plan.output.txt"
            $code = $LASTEXITCODE
          } catch {
            $code = 1
            $_.Exception.Message | Out-File -FilePath "plan.output.txt" -Append
          }

          if ($code -eq 2) {
            'has_changes=true'  | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } elseif ($code -eq 0) {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=false'     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Terraform plan failed with exit code $code" -ForegroundColor Red
          }

          # Only produce views if plan file exists
          if (Test-Path "tfplan.bin") {
            & "$env:TERRAFORM_PATH" show -no-color tfplan.bin > tfplan.txt
            & "$env:TERRAFORM_PATH" show -json     tfplan.bin > tfplan.json
          }

          # Ensure the PowerShell step always exits successfully
          $global:LASTEXITCODE = 0
          exit 0
          
      - name: Summarize plan (outputs + errors if any)
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          $summary = @("### Plan - $($env:LAYER)",
                      "",
                      "- Plan OK: ${{ steps.plan.outputs.plan_ok }}",
                      "- Changes: ${{ steps.plan.outputs.has_changes }}")
          
          if (Test-Path "tfplan.json") {
            $tf = (Get-Content tfplan.json -Raw) | ConvertFrom-Json
            if ($tf.resource_changes) {
              $rc = $tf.resource_changes
              $adds = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'create' }).Count
              $updates = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'update' }).Count
              $deletes = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'delete' }).Count
              $repl = ($rc | Where-Object { ($_.change.actions -contains 'create') -and ($_.change.actions -contains 'delete') }).Count
              $summary += "- Adds: $adds, Changes: $updates, Destroys: $deletes, Replacements: $repl"
            }
            if ($tf.outputs) {
              $summary += ""
              $summary += "**Planned Outputs:**"
              foreach ($k in $tf.outputs.PSObject.Properties.Name) {
                $val = $tf.outputs.$k.value
                $summary += "- $k = $val"
              }
            }
          }
          
          if (Test-Path "plan.output.txt") {
            $output = Get-Content plan.output.txt -Raw
            if ($output.Trim().Length -gt 0 -and '${{ steps.plan.outputs.plan_ok }}' -eq 'false') {
              $summary += ""
              $summary += "**Plan errors/warnings:**"
              $summary += ""
              $summary += '```'
              $summary += $output
              $summary += '```'
            }
          }
          
          if (Test-Path "tfplan.txt") {
            $t = Get-Content tfplan.txt -Raw
            if ($t.Length -gt 50000) { $t = $t.Substring(0,50000) + "`n... (truncated) ..." }
            $summary += ""
            $summary += "<details><summary>Full text plan</summary>"
            $summary += ""
            $summary += '```'
            $summary += $t
            $summary += '```'
            $summary += "</details>"
          }
          
          $summary -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          
      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.LAYER }}-${{ github.sha }}
          path: |
            ${{ env.TF_WORKDIR }}/tfplan.bin
            ${{ env.TF_WORKDIR }}/tfplan.txt
            ${{ env.TF_WORKDIR }}/tfplan.json
            ${{ env.TF_WORKDIR }}/plan.output.txt
          retention-days: 7
          
      - name: Terraform Apply (only if plan OK & changes)
        if: steps.plan.outputs.plan_ok == 'true' && steps.plan.outputs.has_changes == 'true' && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true'
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" apply -input=false -auto-approve tfplan.bin

# ===== APPS =====
  apps:
    name: apps
    needs: [ data ]
    runs-on: [self-hosted, tf-runner]
    permissions: { id-token: write, contents: read }
    env:
      LAYER: apps
      TF_WORKDIR: environments/test-git/apps
      TF_STATE_KEY: test-git/apps/terraform.tfstate
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Terraform Init
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" init `
            -backend-config="bucket=$env:TF_STATE_BUCKET" `
            -backend-config="key=$env:TF_STATE_KEY" `
            -backend-config="region=$env:AWS_REGION" `
            -backend-config="dynamodb_table=$env:TF_LOCK_TABLE" `
            -backend-config="encrypt=true"
            
      - name: Terraform Plan (detect changes)
        id: plan
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          
          # Run plan and capture outputs (ensure step doesn't fail)
          $planArgs = @('plan','-input=false','-out=tfplan.bin','-detailed-exitcode')
          
          try {
            & "$env:TERRAFORM_PATH" @planArgs 2>&1 | Tee-Object -FilePath "plan.output.txt"
            $code = $LASTEXITCODE
          } catch {
            $code = 1
            $_.Exception.Message | Out-File -FilePath "plan.output.txt" -Append
          }

          if ($code -eq 2) {
            'has_changes=true'  | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } elseif ($code -eq 0) {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=false'     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Terraform plan failed with exit code $code" -ForegroundColor Red
          }

          # Only produce views if plan file exists
          if (Test-Path "tfplan.bin") {
            & "$env:TERRAFORM_PATH" show -no-color tfplan.bin > tfplan.txt
            & "$env:TERRAFORM_PATH" show -json     tfplan.bin > tfplan.json
          }

          # Ensure the PowerShell step always exits successfully
          $global:LASTEXITCODE = 0
          exit 0
          
      - name: Summarize plan (outputs + errors if any)
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          $summary = @("### Plan - $($env:LAYER)",
                      "",
                      "- Plan OK: ${{ steps.plan.outputs.plan_ok }}",
                      "- Changes: ${{ steps.plan.outputs.has_changes }}")
          
          if (Test-Path "tfplan.json") {
            $tf = (Get-Content tfplan.json -Raw) | ConvertFrom-Json
            if ($tf.resource_changes) {
              $rc = $tf.resource_changes
              $adds = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'create' }).Count
              $updates = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'update' }).Count
              $deletes = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'delete' }).Count
              $repl = ($rc | Where-Object { ($_.change.actions -contains 'create') -and ($_.change.actions -contains 'delete') }).Count
              $summary += "- Adds: $adds, Changes: $updates, Destroys: $deletes, Replacements: $repl"
            }
            if ($tf.outputs) {
              $summary += ""
              $summary += "**Planned Outputs:**"
              foreach ($k in $tf.outputs.PSObject.Properties.Name) {
                $val = $tf.outputs.$k.value
                $summary += "- $k = $val"
              }
            }
          }
          
          if (Test-Path "plan.output.txt") {
            $output = Get-Content plan.output.txt -Raw
            if ($output.Trim().Length -gt 0 -and '${{ steps.plan.outputs.plan_ok }}' -eq 'false') {
              $summary += ""
              $summary += "**Plan errors/warnings:**"
              $summary += ""
              $summary += '```'
              $summary += $output
              $summary += '```'
            }
          }
          
          if (Test-Path "tfplan.txt") {
            $t = Get-Content tfplan.txt -Raw
            if ($t.Length -gt 50000) { $t = $t.Substring(0,50000) + "`n... (truncated) ..." }
            $summary += ""
            $summary += "<details><summary>Full text plan</summary>"
            $summary += ""
            $summary += '```'
            $summary += $t
            $summary += '```'
            $summary += "</details>"
          }
          
          $summary -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          
      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.LAYER }}-${{ github.sha }}
          path: |
            ${{ env.TF_WORKDIR }}/tfplan.bin
            ${{ env.TF_WORKDIR }}/tfplan.txt
            ${{ env.TF_WORKDIR }}/tfplan.json
            ${{ env.TF_WORKDIR }}/plan.output.txt
          retention-days: 7
          
      - name: Terraform Apply (only if plan OK & changes)
        if: steps.plan.outputs.plan_ok == 'true' && steps.plan.outputs.has_changes == 'true' && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true'
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" apply -input=false -auto-approve tfplan.bin