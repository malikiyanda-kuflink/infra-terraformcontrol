name: tf-plan-and-apply

on:
  pull_request:
    branches: [ main ]
  push:
    tags:
      - 'v*-test'
      - 'v*-staging'
      - 'v*-prod'

permissions:
  id-token: write
  contents: read

concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment:   ${{ steps.parse.outputs.environment }}
      is_deploy:     ${{ steps.parse.outputs.is_deploy }}
      layers_json:   ${{ steps.detect.outputs.layers_json }}
      state_bucket:  ${{ steps.derive.outputs.state_bucket }}
      lock_table:    ${{ steps.derive.outputs.lock_table }}
    steps:
      - name: Parse Environment from Tag (or PRâ†’test)
        id: parse
        shell: bash
        run: |
          ref="${GITHUB_REF}"
          ENV_SLUG="test"
          IS_DEPLOY="false"

          if [[ "$ref" =~ refs/tags/v.*-(test|staging|prod)$ ]]; then
            case "${BASH_REMATCH[1]}" in
              test)
                ENV_SLUG="test"
                ;;
              staging)
                ENV_SLUG="staging"
                ;;
              prod)
                ENV_SLUG="production"
                ;;
            esac
            IS_DEPLOY="true"
          fi

          echo "environment=$ENV_SLUG" >> $GITHUB_OUTPUT
          echo "is_deploy=$IS_DEPLOY"  >> $GITHUB_OUTPUT
          
          echo "ðŸŽ¯ Environment: $ENV_SLUG"
          echo "ðŸš€ Is Deploy: $IS_DEPLOY"

      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Ensure jq is available
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Detect Changed Layers (env-nested, cascade, ordered)
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          ENV_SLUG="${{ steps.parse.outputs.environment }}"

          # Build change list
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            git fetch --no-tags origin "${{ github.base_ref }}" --depth=1
            CHANGED="$(git diff --name-only "origin/${{ github.base_ref }}"...HEAD || true)"
          else
            if git rev-parse -q --verify HEAD^ >/dev/null; then
              CHANGED="$(git diff --name-only HEAD^ HEAD || true)"
            else
              CHANGED="$(git ls-tree -r --name-only HEAD || true)"
            fi
          fi
          echo "Changed files:"; printf "%s\n" "$CHANGED"

          # Detect direct layer touches
          need_foundation=false
          need_platform=false
          need_data=false
          need_apps=false

          while IFS= read -r f; do
            [[ -z "$f" ]] && continue

            # env/layer dirs
            [[ "$f" =~ ^environments/${ENV_SLUG}/foundation/ ]] && need_foundation=true
            [[ "$f" =~ ^environments/${ENV_SLUG}/platform/   ]] && need_platform=true
            [[ "$f" =~ ^environments/${ENV_SLUG}/data/       ]] && need_data=true
            [[ "$f" =~ ^environments/${ENV_SLUG}/apps/       ]] && need_apps=true

            # modules â†’ owning layers
            [[ "$f" =~ ^modules/vpc/|^modules/iam/|^modules/parameter-store/ ]] && need_foundation=true
            [[ "$f" =~ ^modules/eb-waf/|^modules/s3-admin-waf/               ]] && need_platform=true
            [[ "$f" =~ ^modules/rds/|^modules/rds-restored/|^modules/redshift/|^modules/redshift-restored/|^modules/dms-mysql-to-redshift/|^modules/elastic-cache-redis/ ]] && need_data=true
            [[ "$f" =~ ^modules/ec2-|^modules/s3-admin/|^modules/s3-frontend/|^modules/eb-api/ ]] && need_apps=true
          done <<< "$CHANGED"

          # ----- Upstream prerequisite cascade (ONLY) -----
          # apps implies data
          if $need_apps; then
            need_data=true
          fi
          # data implies platform
          if $need_data; then
            need_platform=true
          fi
          # platform implies foundation
          if $need_platform; then
            need_foundation=true
          fi

          # Build ordered unique list
          LAYERS=()
          $need_foundation && LAYERS+=("foundation")
          $need_platform   && LAYERS+=("platform")
          $need_data       && LAYERS+=("data")
          $need_apps       && LAYERS+=("apps")

          # On tag deploy, if *nothing* matched, deploy everything (promotion)
          if [[ ${#LAYERS[@]} -eq 0 && "${{ steps.parse.outputs.is_deploy }}" == "true" ]]; then
            LAYERS=("foundation" "platform" "data" "apps")
          fi

          # Emit compact JSON for downstream matrix/contains()
          JSON=$(printf '%s\n' "${LAYERS[@]}" | jq -R . | jq -sc .)
          echo "layers_json=$JSON" >> "$GITHUB_OUTPUT"
          echo "Detected layers after cascade (ordered): $JSON"

      - name: Derive backend bucket & lock table per environment
        id: derive
        shell: bash
        run: |
          case "${{ steps.parse.outputs.environment }}" in
            test)
              STATE_BUCKET="kuflink-test-states"
              LOCK_TABLE="kuflink-tf-locks-test"
              ;;
            staging)
              STATE_BUCKET="kuflink-staging-states"
              LOCK_TABLE="kuflink-tf-locks-staging"
              ;;
            production)
              STATE_BUCKET="kuflink-prod-states"
              LOCK_TABLE="kuflink-tf-locks-prod"
              ;;
          esac
          echo "state_bucket=$STATE_BUCKET" >> $GITHUB_OUTPUT
          echo "lock_table=$LOCK_TABLE"     >> $GITHUB_OUTPUT
          echo "Using backend: bucket=$STATE_BUCKET, lock=$LOCK_TABLE"

  apply-foundation:
    needs: detect-environment
    if: contains(fromJson(needs.detect-environment.outputs.layers_json), 'foundation')
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT:  ${{ needs.detect-environment.outputs.environment }}
      IS_DEPLOY:    ${{ needs.detect-environment.outputs.is_deploy }}
      LAYER:        foundation
      AWS_REGION:   ${{ vars.AWS_REGION }}
      TF_STATE_BUCKET: ${{ needs.detect-environment.outputs.state_bucket }}
      TF_LOCK_TABLE:   ${{ needs.detect-environment.outputs.lock_table }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Determine AWS Role
        id: aws_role
        run: |
          case "${{ env.ENVIRONMENT }}" in
            test)
              echo "role_arn=${{ secrets.TEST_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "role_arn=${{ secrets.STAGING_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "role_arn=${{ secrets.PRODUCTION_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
          esac
          
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws_role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with: { terraform_wrapper: false }
        
      - name: Terraform Init (CLI backend)
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${ENVIRONMENT}/${LAYER}/terraform.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=${TF_LOCK_TABLE}" \
            -backend-config="encrypt=true"
            
      - name: Terraform Fmt & Validate
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          terraform fmt -check
          terraform validate
          
      - name: Terraform Plan
        id: plan
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          set +e
          terraform plan -no-color -out=tfplan.bin -detailed-exitcode -var="environment=${ENVIRONMENT}" 2>&1 | tee plan_output.txt
          code=${PIPESTATUS[0]}
          echo "exit_code=$code" >> $GITHUB_OUTPUT
          if [ "$code" -eq 2 ]; then echo "has_changes=true" >> $GITHUB_OUTPUT; exit 0
          elif [ "$code" -eq 0 ]; then echo "has_changes=false" >> $GITHUB_OUTPUT; exit 0
          else exit "$code"; fi
          
      - name: Upload Plan
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.ENVIRONMENT }}-${{ env.LAYER }}
          path: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}/tfplan.bin
          if-no-files-found: ignore
          
      - name: Terraform Apply
        if: env.IS_DEPLOY == 'true' && steps.plan.outputs.has_changes == 'true'
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: terraform apply -auto-approve tfplan.bin 2>&1 | tee apply_output.txt
        
      - name: Generate Summary
        if: always()
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          echo "## Terraform Summary - ${{ env.LAYER }} (${{ env.ENVIRONMENT }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f plan_output.txt ]; then
            PLAN_SUMMARY=$(grep -E "Plan:|No changes\." plan_output.txt | tail -1 || echo "Plan completed")
            echo "### ðŸ“‹ Plan" >> $GITHUB_STEP_SUMMARY
            echo "$PLAN_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>View full plan output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat plan_output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -f apply_output.txt ]; then
            sed 's/\x1b\[[0-9;]*m//g' apply_output.txt > apply_output_clean.txt
            APPLY_SUMMARY=$(grep -E "Apply complete!" apply_output_clean.txt | tail -1 || echo "Apply completed")
            echo "### âœ… Apply" >> $GITHUB_STEP_SUMMARY
            echo "$APPLY_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>View full apply output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat apply_output_clean.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

  apply-platform:
    needs: [detect-environment, apply-foundation]
    if: |
      !failure() && !cancelled() &&
      contains(fromJson(needs.detect-environment.outputs.layers_json), 'platform')
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT:  ${{ needs.detect-environment.outputs.environment }}
      IS_DEPLOY:    ${{ needs.detect-environment.outputs.is_deploy }}
      LAYER:        platform
      AWS_REGION:   ${{ vars.AWS_REGION }}
      TF_STATE_BUCKET: ${{ needs.detect-environment.outputs.state_bucket }}
      TF_LOCK_TABLE:   ${{ needs.detect-environment.outputs.lock_table }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Determine AWS Role
        id: aws_role
        run: |
          case "${{ env.ENVIRONMENT }}" in
            test)
              echo "role_arn=${{ secrets.TEST_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "role_arn=${{ secrets.STAGING_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "role_arn=${{ secrets.PRODUCTION_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
          esac
          
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws_role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify dependency state exists (foundation)
        id: prereq_check
        shell: bash
        env:
          TF_STATE_BUCKET: ${{ env.TF_STATE_BUCKET }}
          ENVIRONMENT:     ${{ env.ENVIRONMENT }}
        run: |
          echo "Checking prerequisite Terraform state in s3://${TF_STATE_BUCKET} for env ${ENVIRONMENT}"

          missing=0
          for layer in foundation; do
            key="${ENVIRONMENT}/${layer}/terraform.tfstate"
            if aws s3api head-object --bucket "${TF_STATE_BUCKET}" --key "${key}" >/dev/null 2>&1; then
              echo "âœ” found ${key}"
            else
              echo "âŒ missing ${key}"
              missing=1
            fi
          done

          if [ "$missing" -ne 0 ]; then
            echo "Required base layers are not up. Deploy foundation first."
            exit 1
          fi
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with: { terraform_wrapper: false }
        
      - name: Terraform Init (CLI backend)
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${ENVIRONMENT}/${LAYER}/terraform.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=${TF_LOCK_TABLE}" \
            -backend-config="encrypt=true"
            
      - name: Terraform Fmt & Validate
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          terraform fmt -check
          terraform validate
          
      - name: Terraform Plan
        id: plan
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          set +e
          terraform plan -no-color -out=tfplan.bin -detailed-exitcode -var="environment=${ENVIRONMENT}" 2>&1 | tee plan_output.txt
          code=${PIPESTATUS[0]}
          echo "exit_code=$code" >> $GITHUB_OUTPUT
          if [ "$code" -eq 2 ]; then echo "has_changes=true" >> $GITHUB_OUTPUT; exit 0
          elif [ "$code" -eq 0 ]; then echo "has_changes=false" >> $GITHUB_OUTPUT; exit 0
          else exit "$code"; fi
          
      - name: Upload Plan
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.ENVIRONMENT }}-${{ env.LAYER }}
          path: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}/tfplan.bin
          if-no-files-found: ignore
          
      - name: Terraform Apply
        if: env.IS_DEPLOY == 'true' && steps.plan.outputs.has_changes == 'true'
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: terraform apply -auto-approve tfplan.bin 2>&1 | tee apply_output.txt
        
      - name: Generate Summary
        if: always()
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          echo "## Terraform Summary - ${{ env.LAYER }} (${{ env.ENVIRONMENT }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f plan_output.txt ]; then
            PLAN_SUMMARY=$(grep -E "Plan:|No changes\." plan_output.txt | tail -1 || echo "Plan completed")
            echo "### ðŸ“‹ Plan" >> $GITHUB_STEP_SUMMARY
            echo "$PLAN_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>View full plan output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat plan_output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -f apply_output.txt ]; then
            sed 's/\x1b\[[0-9;]*m//g' apply_output.txt > apply_output_clean.txt
            APPLY_SUMMARY=$(grep -E "Apply complete!" apply_output_clean.txt | tail -1 || echo "Apply completed")
            echo "### âœ… Apply" >> $GITHUB_STEP_SUMMARY
            echo "$APPLY_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>View full apply output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat apply_output_clean.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

  apply-data:
    needs: [detect-environment, apply-platform]
    if: |
      !failure() && !cancelled() &&
      contains(fromJson(needs.detect-environment.outputs.layers_json), 'data')
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT:  ${{ needs.detect-environment.outputs.environment }}
      IS_DEPLOY:    ${{ needs.detect-environment.outputs.is_deploy }}
      LAYER:        data
      AWS_REGION:   ${{ vars.AWS_REGION }}
      TF_STATE_BUCKET: ${{ needs.detect-environment.outputs.state_bucket }}
      TF_LOCK_TABLE:   ${{ needs.detect-environment.outputs.lock_table }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Determine AWS Role
        id: aws_role
        run: |
          case "${{ env.ENVIRONMENT }}" in
            test)
              echo "role_arn=${{ secrets.TEST_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "role_arn=${{ secrets.STAGING_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "role_arn=${{ secrets.PRODUCTION_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
          esac
          
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws_role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify dependency state exists (foundation/platform)
        id: prereq_check
        shell: bash
        env:
          TF_STATE_BUCKET: ${{ env.TF_STATE_BUCKET }}
          ENVIRONMENT:     ${{ env.ENVIRONMENT }}
        run: |
          echo "Checking prerequisite Terraform state in s3://${TF_STATE_BUCKET} for env ${ENVIRONMENT}"

          missing=0
          for layer in foundation platform; do
            key="${ENVIRONMENT}/${layer}/terraform.tfstate"
            if aws s3api head-object --bucket "${TF_STATE_BUCKET}" --key "${key}" >/dev/null 2>&1; then
              echo "âœ” found ${key}"
            else
              echo "âŒ missing ${key}"
              missing=1
            fi
          done

          if [ "$missing" -ne 0 ]; then
            echo "Required base layers are not up. Deploy foundation/platform first."
            exit 1
          fi
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with: { terraform_wrapper: false }
        
      - name: Terraform Init (CLI backend)
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${ENVIRONMENT}/${LAYER}/terraform.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=${TF_LOCK_TABLE}" \
            -backend-config="encrypt=true"
            
      - name: Terraform Fmt & Validate
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          terraform fmt -check
          terraform validate
          
      - name: Terraform Plan
        id: plan
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          set +e
          terraform plan -no-color -out=tfplan.bin -detailed-exitcode -var="environment=${ENVIRONMENT}" 2>&1 | tee plan_output.txt
          code=${PIPESTATUS[0]}
          echo "exit_code=$code" >> $GITHUB_OUTPUT
          if [ "$code" -eq 2 ]; then echo "has_changes=true" >> $GITHUB_OUTPUT; exit 0
          elif [ "$code" -eq 0 ]; then echo "has_changes=false" >> $GITHUB_OUTPUT; exit 0
          else exit "$code"; fi
          
      - name: Upload Plan
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.ENVIRONMENT }}-${{ env.LAYER }}
          path: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}/tfplan.bin
          if-no-files-found: ignore
          
      - name: Terraform Apply
        if: env.IS_DEPLOY == 'true' && steps.plan.outputs.has_changes == 'true'
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: terraform apply -auto-approve tfplan.bin 2>&1 | tee apply_output.txt
        
      - name: Generate Summary
        if: always()
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          echo "## Terraform Summary - ${{ env.LAYER }} (${{ env.ENVIRONMENT }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f plan_output.txt ]; then
            PLAN_SUMMARY=$(grep -E "Plan:|No changes\." plan_output.txt | tail -1 || echo "Plan completed")
            echo "### ðŸ“‹ Plan" >> $GITHUB_STEP_SUMMARY
            echo "$PLAN_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>View full plan output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat plan_output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -f apply_output.txt ]; then
            sed 's/\x1b\[[0-9;]*m//g' apply_output.txt > apply_output_clean.txt
            APPLY_SUMMARY=$(grep -E "Apply complete!" apply_output_clean.txt | tail -1 || echo "Apply completed")
            echo "### âœ… Apply" >> $GITHUB_STEP_SUMMARY
            echo "$APPLY_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>View full apply output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat apply_output_clean.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

  apply-apps:
    needs: [detect-environment, apply-data]
    if: |
      !failure() && !cancelled() &&
      contains(fromJson(needs.detect-environment.outputs.layers_json), 'apps')
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT:  ${{ needs.detect-environment.outputs.environment }}
      IS_DEPLOY:    ${{ needs.detect-environment.outputs.is_deploy }}
      LAYER:        apps
      AWS_REGION:   ${{ vars.AWS_REGION }}
      TF_STATE_BUCKET: ${{ needs.detect-environment.outputs.state_bucket }}
      TF_LOCK_TABLE:   ${{ needs.detect-environment.outputs.lock_table }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine AWS Role
        id: aws_role
        run: |
          case "${{ env.ENVIRONMENT }}" in
            test)
              echo "role_arn=${{ secrets.TEST_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "role_arn=${{ secrets.STAGING_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "role_arn=${{ secrets.PRODUCTION_AWS_OIDC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws_role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify dependency state exists (foundation/platform/data)
        id: prereq_check
        shell: bash
        env:
          TF_STATE_BUCKET: ${{ env.TF_STATE_BUCKET }}
          ENVIRONMENT:     ${{ env.ENVIRONMENT }}
        run: |
          echo "Checking prerequisite Terraform state in s3://${TF_STATE_BUCKET} for env ${ENVIRONMENT}"

          missing=0
          for layer in foundation platform data; do
            key="${ENVIRONMENT}/${layer}/terraform.tfstate"
            if aws s3api head-object --bucket "${TF_STATE_BUCKET}" --key "${key}" >/dev/null 2>&1; then
              echo "âœ” found ${key}"
            else
              echo "âŒ missing ${key}"
              missing=1
            fi
          done

          if [ "$missing" -ne 0 ]; then
            echo "Required base layers are not up. Deploy foundation/platform/data first."
            exit 1
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with: { terraform_wrapper: false }
        
      - name: Terraform Init (CLI backend)
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${ENVIRONMENT}/${LAYER}/terraform.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=${TF_LOCK_TABLE}" \
            -backend-config="encrypt=true"
            
      - name: Terraform Fmt & Validate
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          terraform fmt -check
          terraform validate
          
      - name: Terraform Plan
        id: plan
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          set +e
          terraform plan -no-color -out=tfplan.bin -detailed-exitcode -var="environment=${ENVIRONMENT}" 2>&1 | tee plan_output.txt
          code=${PIPESTATUS[0]}
          echo "exit_code=$code" >> $GITHUB_OUTPUT
          if [ "$code" -eq 2 ]; then echo "has_changes=true" >> $GITHUB_OUTPUT; exit 0
          elif [ "$code" -eq 0 ]; then echo "has_changes=false" >> $GITHUB_OUTPUT; exit 0
          else exit "$code"; fi
          
      - name: Upload Plan
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.ENVIRONMENT }}-${{ env.LAYER }}
          path: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}/tfplan.bin
          if-no-files-found: ignore
          
      - name: Terraform Apply
        if: env.IS_DEPLOY == 'true' && steps.plan.outputs.has_changes == 'true'
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: terraform apply -auto-approve tfplan.bin 2>&1 | tee apply_output.txt
        
      - name: Generate Summary
        if: always()
        working-directory: environments/${{ env.ENVIRONMENT }}/${{ env.LAYER }}
        shell: bash
        run: |
          echo "## Terraform Summary - ${{ env.LAYER }} (${{ env.ENVIRONMENT }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f plan_output.txt ]; then
            PLAN_SUMMARY=$(grep -E "Plan:|No changes\." plan_output.txt | tail -1 || echo "Plan completed")
            echo "### ðŸ“‹ Plan" >> $GITHUB_STEP_SUMMARY
            echo "$PLAN_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>View full plan output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat plan_output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -f apply_output.txt ]; then
            sed 's/\x1b\[[0-9;]*m//g' apply_output.txt > apply_output_clean.txt
            APPLY_SUMMARY=$(grep -E "Apply complete!" apply_output_clean.txt | tail -1 || echo "Apply completed")
            echo "### âœ… Apply" >> $GITHUB_STEP_SUMMARY
            echo "$APPLY_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>View full apply output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat apply_output_clean.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi