name: foundation-test

on:
  push:
    branches: [ test-git ]
    paths:
      - environments/test-git/foundation/**
      - modules/**
  workflow_dispatch:
    inputs:
      auto_apply:
        description: "Auto-apply when a layer has changes?"
        type: boolean
        default: true
        required: false

concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: eu-west-2
  TF_IN_AUTOMATION: "true"
  TF_STATE_BUCKET: kuflink-test-states
  TF_LOCK_TABLE: kuflink-tf-locks-test
  ROLE_ARN: arn:aws:iam::137167813802:role/kuflink-test-github-oidc-terraform
  TERRAFORM_PATH: "C:\\terraform\\terraform.exe"

jobs:
  # ===== FOUNDATION =====
  foundation:
    name: foundation
    runs-on: [self-hosted, tf-runner]
    permissions: { id-token: write, contents: read }
    env:
      LAYER: foundation
      TF_WORKDIR: environments/test-git/foundation
      TF_STATE_KEY: test-git/foundation/terraform.tfstate
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify Terraform
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          Write-Host "TERRAFORM_PATH: $env:TERRAFORM_PATH  Exists: $(Test-Path $env:TERRAFORM_PATH)"
          & "$env:TERRAFORM_PATH" version

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" init `
            -backend-config="bucket=$env:TF_STATE_BUCKET" `
            -backend-config="key=$env:TF_STATE_KEY" `
            -backend-config="region=$env:AWS_REGION" `
            -backend-config="dynamodb_table=$env:TF_LOCK_TABLE" `
            -backend-config="encrypt=true"

      - name: Terraform Plan (detect changes)
        id: plan
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

          # Initialize output file
          "" | Out-File -FilePath "plan.output.txt" -Encoding ASCII

          # Run plan with no-color flag and capture all outputs
          $planArgs = @('plan', '-no-color', '-input=false', '-out=tfplan.bin', '-detailed-exitcode')
          
          Write-Host "Running terraform plan with args: $($planArgs -join ' ')" -ForegroundColor Yellow
          "Running terraform plan with args: $($planArgs -join ' ')" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
          
          $maxRetries = 2
          $retryCount = 0
          $code = 1
          $lastStderr = ""
          
          do {
            if ($retryCount -gt 0) {
              Write-Host "Retry attempt $retryCount of $maxRetries" -ForegroundColor Yellow
              "=== RETRY ATTEMPT $retryCount ===" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
              Start-Sleep -Seconds 30  # Wait 30 seconds between retries
            }
            
            try {
              # Run terraform and capture output
              $process = Start-Process -FilePath "$env:TERRAFORM_PATH" -ArgumentList $planArgs -WorkingDirectory (Get-Location) -RedirectStandardOutput "tf_stdout.txt" -RedirectStandardError "tf_stderr.txt" -Wait -PassThru -NoNewWindow
              $code = $process.ExitCode
              
              # Read and display stdout
              $stdout = ""
              if (Test-Path "tf_stdout.txt") {
                $stdout = Get-Content "tf_stdout.txt" -Raw -Encoding UTF8
                if ($stdout) {
                  Write-Host "STDOUT:" -ForegroundColor Green
                  Write-Host $stdout
                  "=== TERRAFORM STDOUT ===" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
                  $stdout | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
                }
              }
              
              # Read and display stderr
              $stderr = ""
              if (Test-Path "tf_stderr.txt") {
                $stderr = Get-Content "tf_stderr.txt" -Raw -Encoding UTF8
                $lastStderr = $stderr  # Store for retry logic
                if ($stderr) {
                  Write-Host "STDERR:" -ForegroundColor Red
                  Write-Host $stderr
                  "=== TERRAFORM STDERR ===" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
                  $stderr | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
                  
                  # Check if this is a state lock error that might resolve with retry
                  if ($stderr -match "Error acquiring the state lock" -and $retryCount -lt $maxRetries) {
                    Write-Host "State lock detected, will retry after delay..." -ForegroundColor Yellow
                    "State lock detected, will retry after delay..." | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
                  }
                }
              }
              
              # Debug output for exit code
              Write-Host "DEBUG: Terraform exit code = $code, stdout length = $($stdout.Length), stderr length = $($stderr.Length)" -ForegroundColor Cyan
              "DEBUG: Terraform exit code = $code, stdout length = $($stdout.Length), stderr length = $($stderr.Length)" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
              
            } catch {
              $code = 1
              $errorMsg = "PowerShell exception: $($_.Exception.Message)"
              Write-Host $errorMsg -ForegroundColor Red
              "=== POWERSHELL EXCEPTION ===" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
              $errorMsg | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
            }
            
            # Clean up temp files for next iteration
            if (Test-Path "tf_stdout.txt") { Remove-Item "tf_stdout.txt" -Force }
            if (Test-Path "tf_stderr.txt") { Remove-Item "tf_stderr.txt" -Force }
            
            $retryCount++
            
            # Continue if we got a state lock error and haven't exceeded retries
          } while ($code -eq 1 -and $lastStderr -match "Error acquiring the state lock" -and $retryCount -le $maxRetries)

          Write-Host "Terraform plan completed with exit code: $code after $retryCount attempt(s)" -ForegroundColor $(if ($code -eq 0 -or $code -eq 2) { 'Green' } else { 'Red' })
          "Terraform plan completed with exit code: $code after $retryCount attempt(s)" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII

          # CRITICAL DEBUG - Output exit code prominently
          Write-Host "=============================================" -ForegroundColor Magenta
          Write-Host "CRITICAL DEBUG: EXIT CODE = $code" -ForegroundColor Magenta  
          Write-Host "=============================================" -ForegroundColor Magenta
          "====== CRITICAL DEBUG: EXIT CODE = $code ======" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII

          # Set outputs based on exit code
          if ($code -eq 2) {
            'has_changes=true'  | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Setting: has_changes=true, plan_ok=true (EXIT CODE 2)" -ForegroundColor Green
            "Setting: has_changes=true, plan_ok=true (EXIT CODE 2)" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
          } elseif ($code -eq 0) {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=true'      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Setting: has_changes=false, plan_ok=true (EXIT CODE 0)" -ForegroundColor Green  
            "Setting: has_changes=false, plan_ok=true (EXIT CODE 0)" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
          } else {
            'has_changes=false' | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            'plan_ok=false'     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "Setting: has_changes=false, plan_ok=false (EXIT CODE $code - ERROR)" -ForegroundColor Red
            "Setting: has_changes=false, plan_ok=false (EXIT CODE $code - ERROR)" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
          }

          # Only produce views if plan file exists
          if (Test-Path "tfplan.bin") {
            Write-Host "Generating plan views..." -ForegroundColor Yellow
            try {
              & "$env:TERRAFORM_PATH" show -no-color tfplan.bin > tfplan.txt
              & "$env:TERRAFORM_PATH" show -json tfplan.bin > tfplan.json
              Write-Host "Plan views generated successfully" -ForegroundColor Green
            } catch {
              Write-Host "Failed to generate plan views: $($_.Exception.Message)" -ForegroundColor Red
              "Failed to generate plan views: $($_.Exception.Message)" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
            }
          } else {
            Write-Host "tfplan.bin not found - plan likely failed" -ForegroundColor Red
            "tfplan.bin not found - check stderr above for terraform error details" | Out-File -FilePath "plan.output.txt" -Append -Encoding ASCII
          }

          # Exit with the actual terraform exit code - let the job fail if terraform failed
          Write-Host "Step completed with terraform exit code: $code" -ForegroundColor $(if ($code -eq 0 -or $code -eq 2) { 'Blue' } else { 'Red' })
          if ($code -eq 0 -or $code -eq 2) {
            Write-Host "Terraform plan succeeded" -ForegroundColor Green
          } else {
            Write-Host "Terraform plan failed - failing the job" -ForegroundColor Red
          }
          
          # Set the actual exit code - don't override it
          $global:LASTEXITCODE = $code
          exit $code

      - name: Summarize plan (outputs)
        # Always run this step, even if plan failed
        if: always()
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          $summary = @()
          $summary += "### Plan - $($env:LAYER)"
          $summary += ""
          $summary += "- Changes: ${{ steps.plan.outputs.has_changes }}"
          $summary += "- Plan OK: ${{ steps.plan.outputs.plan_ok }}"

          # Show errors first if plan failed
          if ('${{ steps.plan.outputs.plan_ok }}' -eq 'false') {
            $summary += ""
            $summary += "## ❌ Plan Failed - Job Will Fail"
            
            if (Test-Path "plan.output.txt") {
              # Read with ASCII encoding to avoid character issues
              $errorContent = Get-Content "plan.output.txt" -Raw -Encoding ASCII
              if ($errorContent -and $errorContent.Trim()) {
                
                # Look for terraform stderr section specifically  
                if ($errorContent -match "=== TERRAFORM STDERR ===[\r\n]+(.*?)(?===|\z)") {
                  $terraformError = $matches[1].Trim()
                  if ($terraformError) {
                    $summary += ""
                    $summary += "**Terraform Error:**"
                    $summary += '```'
                    if ($terraformError.Length -gt 6000) { 
                      $terraformError = $terraformError.Substring(0,6000) + "`n... (truncated) ..." 
                    }
                    # Clean up encoding issues more aggressively
                    $terraformError = $terraformError -replace '[^\x20-\x7E\r\n\t]', ''  # Keep only printable ASCII + whitespace
                    $summary += $terraformError
                    $summary += '```'
                  }
                }
                
                $summary += ""
                $summary += "<details><summary>❗ Full Error Log (click to expand)</summary>"
                $summary += ""
                $summary += '```'
                if ($errorContent.Length -gt 8000) { 
                  $errorContent = $errorContent.Substring(0,8000) + "`n... (truncated) ..." 
                }
                # Clean up any remaining encoding issues more thoroughly - use ASCII encoding
                $errorContent = [System.Text.Encoding]::ASCII.GetString([System.Text.Encoding]::ASCII.GetBytes($errorContent))
                $summary += $errorContent
                $summary += '```'
                $summary += "</details>"
              } else {
                $summary += "- **Error log file is empty**"
              }
            } else {
              $summary += "- **No error log found in plan.output.txt**"
            }
          } else {
            $summary += ""
            $summary += "## ✅ Plan Succeeded"
          }

          if (Test-Path "tfplan.json") {
            $tf = (Get-Content tfplan.json -Raw) | ConvertFrom-Json
            
            if ($tf.resource_changes) {
              $rc = $tf.resource_changes
              $adds     = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'create' }).Count
              $updates  = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'update' }).Count
              $deletes  = ($rc | Where-Object { ($_.change.actions -join ',') -eq 'delete' }).Count
              $repl     = ($rc | Where-Object { ($_.change.actions -contains 'create') -and ($_.change.actions -contains 'delete') }).Count
              $summary += "- Adds: $adds, Changes: $updates, Destroys: $deletes, Replacements: $repl"
            }

            if ($tf.output_changes) {
              $vpcOutputs = @()
              $iamOutputs = @()
              $dbOutputs = @()
              $computeOutputs = @()
              $otherOutputs = @()
              $sensitiveCount = 0
              
              foreach ($outputName in $tf.output_changes.PSObject.Properties.Name) {
                $outputChange = $tf.output_changes.$outputName
                
                if ($outputChange.after_sensitive -eq $true) {
                  $sensitiveCount++
                  continue
                }
                
                if ($outputChange.after -ne $null) {
                  if ($outputChange.after -is [string]) {
                    $displayValue = $outputChange.after
                  } elseif ($outputChange.after -is [array]) {
                    $displayValue = "[$($outputChange.after -join ', ')]"
                  } else {
                    $displayValue = $($outputChange.after | ConvertTo-Json -Compress)
                  }
                  
                  $outputLine = "- $outputName = $displayValue"
                  
                  if ($outputName -match "vpc|subnet|gateway|route|cidr|network") {
                    $vpcOutputs += $outputLine
                  } elseif ($outputName -match "role_arn|instance_profile|iam_") {
                    $iamOutputs += $outputLine
                  } elseif ($outputName -match "db_|database|rds_|redshift|dms_") {
                    $dbOutputs += $outputLine
                  } elseif ($outputName -match "ami|instance|ec2_") {
                    $computeOutputs += $outputLine
                  } else {
                    $otherOutputs += $outputLine
                  }
                }
              }
              
              $totalOutputs = ($tf.output_changes.PSObject.Properties | Measure-Object).Count
              $visibleOutputs = $totalOutputs - $sensitiveCount
              $summary += ""
              $summary += "**Planned Outputs ($visibleOutputs shown, $sensitiveCount sensitive hidden):**"
              
              if ($vpcOutputs.Count -gt 0) {
                $summary += ""
                $summary += "**VPC and Networking ($($vpcOutputs.Count)):**"
                $summary += $vpcOutputs
              }
              
              if ($iamOutputs.Count -gt 0) {
                $summary += ""
                $summary += "**IAM Roles and Policies ($($iamOutputs.Count)):**"
                $summary += $iamOutputs
              }
              
              if ($dbOutputs.Count -gt 0) {
                $summary += ""
                $summary += "**Database Resources ($($dbOutputs.Count)):**"
                $summary += $dbOutputs
              }
              
              if ($computeOutputs.Count -gt 0) {
                $summary += ""
                $summary += "**Compute Resources ($($computeOutputs.Count)):**"
                $summary += $computeOutputs
              }
              
              if ($otherOutputs.Count -gt 0) {
                $summary += ""
                $summary += "**Other Resources ($($otherOutputs.Count)):**"
                $summary += $otherOutputs
              }
              
            } else {
              $summary += ""
              $summary += "**No output changes found**"
            }

          } else {
            $summary += ""
            if ('${{ steps.plan.outputs.plan_ok }}' -eq 'false') {
              $summary += "- **tfplan.json not found (expected due to plan failure)**"
            } else {
              $summary += "- **ERROR: tfplan.json not found despite successful plan**"
            }
          }

          if (Test-Path "tfplan.txt") {
            $summary += ""
            $summary += "<details><summary>Full text plan (click to expand)</summary>"
            $summary += ""
            $summary += '```'
            $t = Get-Content tfplan.txt -Raw
            if ($t.Length -gt 15000) { 
              $t = $t.Substring(0,15000) + "`n... (truncated) ..." 
            }
            $summary += $t
            $summary += '```'
            $summary += "</details>"
          }

          # Show raw terraform output only if plan succeeded (to avoid duplication)
          if ('${{ steps.plan.outputs.plan_ok }}' -eq 'true' -and (Test-Path "plan.output.txt")) {
            $rawOutput = Get-Content "plan.output.txt" -Raw -Encoding ASCII
            if ($rawOutput -and $rawOutput.Trim()) {
              $summary += ""
              $summary += "<details><summary>Full Terraform Output (click to expand)</summary>"
              $summary += ""
              $summary += '```'
              # Even smaller truncation to prevent issues
              if ($rawOutput.Length -gt 8000) { 
                $rawOutput = $rawOutput.Substring(0,8000) + "`n... (truncated for summary) ..." 
              }
              # Convert to clean ASCII
              $bytes = [System.Text.Encoding]::UTF8.GetBytes($rawOutput)
              $rawOutput = [System.Text.Encoding]::ASCII.GetString($bytes) -replace '[^\x20-\x7E\r\n\t]', ''
              $summary += $rawOutput
              $summary += '```'
              $summary += "</details>"
            }
          }

          $summary -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8

      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        # Always run this step, even if plan failed - artifacts are needed for debugging
        if: always()
        with:
          name: tfplan-${{ env.LAYER }}-${{ github.sha }}
          # Use a more flexible path pattern that includes error outputs
          path: |
            ${{ env.TF_WORKDIR }}/tfplan.bin
            ${{ env.TF_WORKDIR }}/tfplan.txt
            ${{ env.TF_WORKDIR }}/tfplan.json
            ${{ env.TF_WORKDIR }}/plan.output.txt
          # Don't fail the job if some files are missing
          if-no-files-found: warn
          retention-days: 7

      - name: Terraform Apply (only if changes)
        # Only apply if plan succeeded AND has changes
        if: steps.plan.outputs.has_changes == 'true' && steps.plan.outputs.plan_ok == 'true' && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true'
        working-directory: ${{ env.TF_WORKDIR }}
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          & "$env:TERRAFORM_PATH" apply -input=false -auto-approve tfplan.bin